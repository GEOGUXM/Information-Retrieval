http://expect.nist.gov/doc/cgi.pdf

   Writing CGI scripts in Tcl Don Libes National Institute of Standards
   and Technology libes@nist.gov Abstract CGI scripts have many advantages
   over statically writ- ten HTML. For example, CGI scripts can
   automatically CGI scripts enable dynamic generation of HTML pages.
   adapt to changes in the environment, such as the date in This paper
   describes how to write CGI scripts using Tcl. the previous example. CGI
   scripts can run programs, Many people use Tcl for this purpose already
   but in an include and process data, and just about anything that ad hoc
   way and without realizing many of the more non- can be done in
   traditional programs. obvious benefits. This paper reviews these
   benefits and provides a framework and examples. Canonical solu- CGI
   scripts are particularly worthwhile in handling Web tions to HTML
   quoting problems are presented. This forms. Web forms allow users to
   enter data into a page paper also discusses using Tcl for the
   generation of dif- and then send the results to a Web server for
   processing. ferent formats from the same document. As an exam- The Web
   form itself does not have to be generated by a ple, FAQ generation in
   both text and HTML are CGI script. However, data entered by a user may
   described. require a customized response. Therefore, a dynami- cally
   generated response via a CGI script is appropriate. Keywords: CGI; FAQ;
   HTML generation; Tcl; World Since the response may produce another
   form, it is com- Wide Web mon to generate forms dynamically as well as
   their responses. Introduction CGI Scripts Are Just a Subset of Dynamic
   CGI scripts enable dynamic generation of HTML pages [BLee].
   Specifically, CGI scripts generate HTML in HTML Generation response to
   requests for Web pages. For example, a CGI scripts are a special case
   of generated HTML. static Web page containing the date might look like
   this: Generated HTML means that another program produced

   The date is Mon Mar 4 12:50:10 EST the HTML. There can be a payoff in
   programmatic gen- 1996. eration even if it is not demanded by the CGI
   environ- ment. I will describe this idea further later in the paper.
   This page was constructed by manually running the date command and
   pasting its output in the page. The page Simply embedding HTML in Tcl
   scripts does not in will show that same date each time it is requested,
   until itself provide any payoff. For instance, consider the the file is
   manually rewritten with a different date. preparation of a page
   describing various types of wid- gets, such as button widgets, dial
   widgets, etc. Ignoring Using a CGI script, it is possible to
   dynamically gener- the body paragraphs, the headers could be generated
   as ate the date. Each time the file is requested, it will show follows:
   the current date. This script (and all others in this paper) are
   written in Tcl [Ouster]. puts "

  Button Widgets

   " puts "

  Dial Widgets

   " puts "Content-type: text/html\n" puts "

   The date is [exec date]." Much of this is redundant and suggests the
   use of a pro- cedure such as this one: The first puts command
   identifies how the browser should treat the remainder of the data  in
   this case, as proc h3 {header} { text to be interpreted as HTML. For
   all but esoteric puts "

  $header

   " uses, this same first line will be required in every CGI } script.
   Now the script can be rewritten: h3 "Button Widget" Reprinted from The
   Proceedings of the Fourth Annual Tcl/Tk Workshop `96, Monterey, CA,
   July 10-13, 1996. h3 "Dial Widget" technique shown earlier suggests two
   procedures: text Notice that you no longer have to worry about adding
   and username. text is the application-independent closing tags such as
   /h3 or putting them in the right HTML interface. username is the
   application-specific place. Also, changing the heading level is
   isolated to interface. An example definition for username is shown one
   place in each line. below. Remember that this is specific to a
   particular application. In this case, a literal prompt is shown (the
   Using a procedure name specifically tied to an HTML HTML markup for
   this would be defined in yet another tag has drawbacks. For example,
   consider code that has procedure). Then the 10-character entry box
   containing level 3 headings for both Widgets and Packages. Now some
   default value. suppose you decide to change just the Widgets to level
   2. You would have to look at each h3 instance and man- proc username
   {name defvalue} { prompt "Username" ually decide whether it is a Widget
   or a Package. text $name $defvalue 10 } In order to change groups of
   headers that are related, it is helpful to use a logical name rather
   than one specifi- When the form is filled out, the user's new value
   will be cally tied to an HTML tag. This can be done by defin- provided
   as the value for the variable named by the first ing an
   application-specific procedure such as one for parameter, stored here
   in "name". Later in this paper, widget headers: I'll go into this in
   more detail. proc widget_header {heading} { A good definition for text
   is relatively ugly because it h2 "$header Widget" must do the hard work
   of adding quotes around each } value at the same time as doing the
   value substitutions. proc package_header {heading} { h3 "$heading
   Package" This is a good demonstration of something you want to } write
   as few times as possible  once, ideally. In con- trast, you could have
   hundreds of application-specific The script can then be written: text
   boxes. Those procedures are trivial to write and widget_header "Button"
   make all forms consistent. In the example above, each widget_header
   "Dial" call to username would always look identical. package_header
   "Object" proc text {name defvalue {size 50}} { Now all the widget
   header formats are defined in one puts " \"$defvalue\"_______" only the
   header level, but any additional formatting. } Here, the word "Widget"
   is automatically appended, but Once all these procedures exist, the
   actual code to add a you can imagine other formatting such as adding
   hyper- username entry to a form is trivial: links, rules, and images.
   username new_user $user This style of scripting makes up for a
   deficiency of HTML: HTML lacks the ability to define application- Many
   refinements can be made. For example, it is com- specific tags. mon to
   use Tcl variables to mirror the form variables. The rewrite in Figure 1
   tests whether the named form Form Generation variable is also a Tcl
   variable. If so, the value is used as the default for the entry. The
   idea of logical tags is equally useful for generation of Web forms. For
   example, consider generation of an If username called this procedure,
   the second argument entry box. Naively rendered in Tcl, a 10-character
   entry could be omitted if the variable name was identical to box might
   look this way: the first argument. For example: puts " __________"
   username User This is fine if there is only one place in your code
   which An explicit value can be supplied in this way: requires a
   username. If you have several, it is more con- username User=don
   venient to place this in a procedure. Dumping this all into a procedure
   simplifies things a little, but enough And arbitrary tags can be added
   as follows: additional attributes on the input tag can quickly render
   username User=don size=10 \ the new procedure impenetrable. Applying
   the same maxlength=5 Many other procedures are required for a full
   implemen- you must examine all of them. By using logical proce- tation.
   Here are two more which will be used in the dure names, that trap is
   avoided. For example, suppose remainder of the paper. The procedure "p"
   starts a new that you want hostnames to always appear the same way.
   paragraph and prints out its argument. The procedure But there is no
   hostname directive in HTML. So you "put" prints its argument with no
   terminating newline. could arbitrarily choose bold and write: And puts,
   of course, can be called directly. proc hostname {s} { proc p {s} {
   return [bold $s] puts "

   $s" } }proc put {s} { An example using this is: puts -nonewline "$s" }
   p "You may ftp the files from [host $ftphost] or [host
   $ftpbackuphost]." Inline Directives If you later decide to change the
   appearance of host- names to, say, italics, it is now very easy to do
   so. Sim- Some HTML tags affect characters rather than complete ply
   change the one-line definition of the hostname elements. For example, a
   word can be made bold by procedure. surrounding it with and . As
   before, redun- dancy can be eliminated by using a procedure: URLs proc
   bold {s} { puts "$s" URLs have a great deal of redundancy in them, so
   using } procedures can provide dramatic benefits in readability and
   maintainability. Similarly to the previous section, Unlike the earlier
   examples, it is not desirable to have hyperlinks can be treated as
   inline directives. By pre- character-based procedures call puts
   directly. Other- storing all URLs, generation of a URL then just
   requires wise, scripts end up looking like this: a reference to the
   appropriate one. While separate vari- put "I often use " ables can be
   used for each URL, a single array bold "Tcl" (_cgi_link) provides all
   URL tags with their own put "to program." namespace. This namespace is
   managed with a proce- These character-based procedures can be made more
   dure called link. For example, suppose that you want to readable by
   having them return their results like this: produce the following
   display in the browser: proc bold {s} { I am married to Don Libes who
   works in the return "$s" Manufacturing Collaboration Technologies }
   Group at NIST. Using these inline directives, scripts become much more
   Using the link procedure, with appropriate link defini- readable:
   tions, the scripting to produce this is simple: p "I often use [bold
   Tcl] to p "I am married to [link Libes] who program." works in the
   [link MCTG] at [link NIST]." Explicit use of a procedure such as bold
   shares the same drawbacks as explicit use of procedures such as h2 and
   This expands to a sizeable chunk of HTML: h3. If you later decide to
   change a subset of some uses, proc text {nameval args} { regexp
   "(\[^=]*)(=?)(.*)" $nameval dummy name q value put "
   \"[quote_html_______" } Figure 1: Procedure to create a generic text
   entry I am married to Don Libes who works in the Manufacturing lute
   URL. However, it is much simpler to create a few Collaboration
   Technologies Group helper variables to further minimize redundancy.
   Figure at NIST. home pages all exist in the same staff directory.
   Needless to say, working on such raw text is the bane of If the
   location of any one staff member's page changes, HTML page maintainers.
   Yet HTML has no provisions only one line needs to be changed. More
   importantly, if itself for reducing this complexity.1 the directory for
   the MSID staff pages changes, only one The link procedure is shown in
   Figure 2. It returns the line needs to be changed. MSID_STAFF is
   dependent formatted link given the tag name as its first argument. on
   another variable that defines the hostname. The host- name is stored in
   a separate variable because 1) it is likely to change and 2) there are
   other links that depend 1. It is tempting to think that relative URLs
   on it. can simplify this, but relative URLs only apply to URLs that
   are, well, relative. In Figure 4 shows some examples of hosts. this
   example, the URLs point to a different There are no restrictions on tag
   names or display names. host than the one where the referring page For
   example, sometimes it is useful to display "Don". lives. Even if this
   isn't the case, I avoid rel- Sometimes, the more formal "Don Libes" is
   appropri- ative URLs because they prevent other peo- ate. This is done
   by defining two links with different ple from copying the raw HTML and
   names but pointing to the same URL. This is shown in pasting it into
   their own page (again, on Figure 5. another site) without substantial
   effort in first making the URLs absolute. proc link {args} { global
   _cgi_link set tag [lindex $args 0] if {[llength $args] == 3} { set
   _cgi_link($tag) \ "[lindex $args 1]" }return $_cgi_link($tag) Figure 2:
   Procedure to access a database of URL links. set MSID_STAFF
   $MSID_HOST/msid/staff link Steve "Steve Ray" $MSID_STAFF/ray.steve.html
   link Don "Don Libes" $MSID_STAFF/libes.don.html link Josh "Josh Lubell"
   $MSID_STAFF/josh.lubell.html Figure 3: Create links to several
   colleagues who home pages all exist in the same staff directory. set
   MSID_HOST http://elib.cme.nist.gov set NIST_HOST http://www.nist.gov
   set ORA_HOST http://www.ora.com Figure 4: Some examples of hosts. link
   Don "Don" $MSID_STAFF/libes.don.html link Libes "Don Libes"
   $MSID_STAFF/libes.don.html Figure 5: Create links to the same URL but
   display them to the user differently. Similarly, there are no
   restrictions on the tag names ing conversions are rather interesting
   but understanding themselves. Consider the link definitions in Figure
   6. them is outside the point of this paper. These are used in
   paragraphs such as this one: The converse procedure to unquote_input is
   shown p "You can ftp Expect from below. This transformation is usually
   done automati- ftp.cme.nist.gov as [link Expect.Z] cally by Web
   browsers. However, it can be useful if or [link Expect.gz]" your CGI
   script needs to send a URL through some A browser shows this as: other
   means such as an advertisement on TV. You can ftp Expect from
   ftp.cme.nist.gov as proc quote_url {in} { pub/expect/expect.tar.Z or
   ...gz. regsub -all " " $in "+" in regsub -all "%" $in "%25" in Having
   link dependencies localized to one place greatly return $in aids
   maintenance and testing. For example, if you have } a set of pages that
   use the definitions (i.e., by sourcing In theory, this procedure should
   perform additional them), editing that one file automatically updates
   all of character translations. However, you should avoid gen- the other
   pages the next time they are regenerated. This erating such characters
   since receiving URLs outside of is useful for testing groups of pages
   on a different a browser requires hand-treatment by users. In these
   sit- server, such as a test server before moving them over to uations,
   all bizarre character sequences should be a production location. Even
   smaller moves can benefit. avoided. For the purposes of testing
   (feeding input For example, it is common to move directories around
   back), additional translation is also unnecessary since or create new
   directories and just move some of the files any other unquoted
   characters will be passed untouched. around. Suppressing HTML
   Interpretation Quoting In most contexts, strings which contain strings
   that look HTML values must be quoted at different times and in like
   HTML will be interpreted as HTML. For example, different ways.
   Unfortunately, the standards are hard to if you want to display the
   literal string "", it must be encoded so that the "<" is not figuring
   out the quoting rules is tricky because simple turned into a hyperlink
   specification. Other special cases don't require quoting and many
   browsers handle characters must be similarly protected. This can be
   various error cases differently. It can be very difficult to done using
   quote_html, shown below: deduce what is correct when your own browser
   accepts erroneous code. This section presents procedures for proc
   quote_html {s} { handling quoting. # ampersand must be done first!
   regsub -all {&} $s {\&} s regsub -all {"} $s {\"} s CGI Arguments
   regsub -all {<} $s {\<} s regsub -all {>} $s {\>} s CGI scripts can
   receive input from either forms or return $s URLs. For example, in a
   URL specification such as } http://www.nist.gov/expect?help=input+foo,
   anything to This can be used to simplify other procedures. Adding the
   right of the question mark becomes input to the CGI explicit double
   quotes before returning the final value script (which conversely is to
   the left of the question allows simplification of many other
   procedures. mark). Assuming this new procedure is called dquote_html,
   Various peculiar translations must be performed on the consider the
   earlier text entry procedure which had the raw input to restore it to
   the original values supplied by code fragment the user. For example,
   the user-supplied string "foo bar" value=\"$defvalue\" is changed to
   "foo+bar". This is undone by the first reg- sub in unquote_input (shown
   in Figure 7). The remain- This could be rewritten: value=[dquote_html
   $defvalue] link Expect.Z "pub/expect/expect.tar.Z"
   $EXPECT_DIR/expect.tar.Z link Expect.gz "...gz"
   $EXPECT_DIR/expect.tar.gz Figure 6: Link tags and definitions can be
   very unusual. There are no restrictions. Argument Cracking
   Import/Export As described earlier, input strings to a CGI script are
   Variables are not automatically entered into separate encoded by the
   browser. Besides the transformations global variables or the env array
   because that would described already, the browser also packs all
   variable open a security hole. Instead, variables must be explic-
   values together in the form variable1=value1&variable2 itly requested.
   Several procedures simplify this. The =value2&variableN=valueN.
   procedure most commonly used is "import". The input procedure (Figure
   8) splits the input back into import is called for each variable
   defined from the its specific variable/value pairs leaving them in a
   global invoking form. For example, if a form used an entry array called
   _cgi_var. Any variable ending with the with "name=foo", the command
   "import foo" would string "List" causes its value to be treated as a
   Tcl list. define foo as a Tcl variable with the value contained in This
   allows, for example, multiple elements of a listbox the entry. The
   command import_cookie is a variation to be extractable as individual
   elements. that obtains the value from a cookie variable  a mecha- nism
   that allows client-side caching of variables. If the procedure is run
   in the CGI environment (i.e., via an HTTPD server), input is
   automatically read from the proc import {name} { environment. If not
   run from the CGI environment (i.e., upvar $name var via the command
   line), the argument is used as input. upvar #0 _cgi_uservar($name) val
   This is very useful for testing. An explicit argument set var $val
   obviates the need for using a real form page to drive the } script and
   means it is easily run from the command line or a debugger. Form
   variables are automatically exported to the called CGI script. It is
   sometimes necessary to export other If the global variable _cgi(debug)
   is set to 1, the proce- variables. This must be done explicitly. Figure
   9 shows dure prints the input string before doing anything else. the
   export procedure which exports the named variable. This is useful
   because it may then be cut and pasted into Similar to the text
   procedure, if the first argument is in the procedure argument for
   debugging purposes, as was the form "var=value", the variable as
   exported with the just mentioned. given value. Otherwise, the variable
   is treated as a Tcl variable and its value is used. proc unquote_input
   {buf} { # rewrite "+" back to space regsub -all {\+} $buf {\ } buf #
   protect $ so Tcl won't do variable expansion regsub -all {\$} $buf {\$}
   buf # protect [ so Tcl doesn't do evaluation regsub -all {\[} $buf {\[}
   buf # protect quotes so Tcl doesn't terminate string early regsub -all
   \" $buf \\\" buf # replace line delimiters with newlines regsub -all
   "%0D%0A" $buf "\n" buf # Mosaic sends just %0A. This is handled in the
   next command. # prepare to process all %-escapes regsub -all
   {%([A-F0-9][A-F0-9])} $buf {[format %c 0x\1]} buf # Mosaic sends just
   %0A. This is handled in the next command. # prepare to process all
   %-escapes regsub -all {%([A-F0-9][A-F0-9])} $buf {[format %c 0x\1]} buf
   # process %-escapes and undo all protection eval return \"$buf\" }
   Figure 7: Translate HTML-style input to original data. Error Handling
   catch errors, and attempt to do something useful. The two arguments,
   head and body, are blocks of Tcl com- The CGI environment makes no
   special provisions for mands which create the head and body of an HTML
   errors. Thus, error processing requires explicit handling form. An
   example is shown later. by the application programmer. If none is made,
   any error messages produced (e.g., by the Tcl interpreter) If the
   global value _cgi(debug) is 1, the script error is are sent on to the
   client browser. These are rarely mean- formatted and printed to the
   screen so that it is readable. ingful to the user. Even worse, they can
   be misinter- If debug is 0, a simple message is printed saying that an
   preted as HTML in which case the result is error occurred and that the
   "diagnostics are being incomprehensible even to the script creator.
   emailed to the service system administrator". At the same time, mail is
   sent to the service administrator. The The procedure in Figure 10
   provides a framework to mail includes everything about the environment
   that is evaluate the body of the CGI script, to automatically necessary
   to reproduce the problem including the error, proc input {{fakeinput
   {}}} { global env _cgi _cgi_uservar if {![info exists
   env(REQUEST_METHOD)]} { set input $fakeinput;# running by hand, so fake
   it } elseif { $env(REQUEST_METHOD) == "GET" } { set input
   $env(QUERY_STRING) } else { set input [read stdin $env(CONTENT_LENGTH)]
   }# if script blows up later, enable access to the original input. set
   _cgi(input) $input # good for debugging! if {$_cgi(debug)} { puts "
$input

   " } set pairs [split $input &] foreach pair $pairs { regexp (.*)=(.*)
   $pair dummy varname val set val [unquote_input $val] # handle lists of
   values correctly if [regexp List$ $varname] { lappend
   _cgi_uservar($varname) $val } else { set _cgi_uservar($varname) $val }
   } # repeat loop above but for cookies } Figure 8: Retrieve CGI input
   proc export {nameval} { regexp "(\[^=]*)(=?)(.*)" $nameval dummy name q
   value if {$q != "="} { set value [uplevel set $name] } put " " } Figure
   9: Export a variable to the CGI script. the script name, and the input.
   The implementation colors, etc., while the body is responsible for
   importing, shown here is skeletal. In the actual definition, a variety
   exporting, and generation of text and graphical elements of other
   interesting problems are handled. For instance, as has already been
   described. A skeletal example is cookie definitions must appear in the
   output before any shown in Figure 11 HTML. However, cookies are more
   easily generated as one of the final results in a script. This and
   other prob- The title procedure (not shown) produces all of the usual
   lems are solved by the full implementation, however the HTML
   boilerplate including titles, backgrounds, etc. A details are beyond
   the scope of this paper. form procedure simplifies the calling
   conventions for establishing any forms. This is not difficult. However,
   Using the procedures defined, CGI scripts become very of critical
   importance is noting that a form is in simple. They all start out by
   sourcing the CGI support progress. Because some browsers won't show
   anything routines. Then cgi_eval is called with arguments to cre- if a
   form hasn't been ended (i.e., "/form"), the error han- ate the head and
   body. The head generates titles, link dler must prematurely close the
   form if an unexpected proc cgi_eval {head body} { global env _cgi set
   _cgi(body) "$head;cgi_body_start;app_body_start;$body;app_body_end"
   uplevel #0 { cgi_body_start if 1==[catch $_cgi(body)] { # errors
   occurred, handle them set _cgi(errorInfo) $errorInfo # close possible
   open form because some # browsers won't show errors otherwise if [info
   exists _cgi(form_in_progress)] { puts "
   " } h3 "An internal error was detected in the service software. \ The
   diagnostics are being emailed to the service\ system administrator." if
   {$_cgi(debug)} { puts "Heck, since you're debugging, I'll show you the\
   errors right here:" # suppress formatting puts "
$_cgi(errorInfo)

   " } else { mail_start $_cgi(email_admin) mail_add "Subject: $_cgi(name)
   problem" mail_add if {$env(REQUEST_METHOD) != "by hand"} { mail_add
   "CGI environment:" mail_add "REQUEST_METHOD: $env(REQUEST_METHOD)"
   mail_add "SCRIPT_NAME: $env(SCRIPT_NAME)" catch {mail_add
   "HTTP_USER_AGENT: $env(HTTP_USER_AGENT)"} catch {mail_add "REMOTE_ADDR:
   $env(REMOTE_ADDR)"} catch {mail_add "REMOTE_HOST: $env(REMOTE_HOST)"}
   }mail_add "input:" mail_add "$_cgi(input)" mail_add "errorInfo:"
   mail_add "$_cgi(errorInfo)" mail_end } }cgi_body_end } } Figure 10:
   Framework to catch errors and report them intelligently. error occurs.
   Saving this information is done with a options. cgi_body_end is anal-
   simple global variable. The form procedure is shown in ogous. Figure
   12. All of the procedures described so far can be invoked Many other
   utilities are necessary such as procedures with "cgi_" prepended (if
   they do not already begin that for each type of form element. Space
   prevents inclusion way). In practice, CGI scripts are generally quite
   short of them. Several other miscellaneous utilities complete so this
   isn't often useful  and writing things like the basic implementation of
   the procedures that appear "cgi_h2" is particularly irritating. However
   conflicts in this paper. A few are mentioned here to give a flavor with
   other namespaces can occasionally make such pre- for what is necessary:
   fixes a necessary evil. cgi Converts a form name to a Several
   procedures are expected to be redefined by the complete URL. user. Here
   are two examples that appear in the body procedure earlier. mail_start
   Generates headers and writes them to a new file representing
   app_body_start Application-supplied proce- a mail message to be sent.
   dure, typically for writing ini- tial images or headers common mail_add
   Writes a new line to the tempo- to all pages. rary mail file.
   app_body_end Application-supplied proce- mail_end Appends a signature
   to the dure, typically for writing sig- temporary mail file, sends it,
   nature lines, last-update-by, and deletes the file. etc. cgi_body_start
   Generates the tag and handles user requests such as backgrounds and
   various color source cgi.tcl cgi_eval { title "Password Change
   Acknowledgment" input "name=libes&old=swordfish&new1=tgif23&new2=tgif23
   } {import name import old ... other stuff form password { spawn
   /bin/passwd expect "Password:" ... } } Figure 11: Skeletal example of
   the CGI procedures in use. proc form {name cmd} { global _cgi set
   _cgi(form_in_progress) 1 puts "" uplevel $cmd puts "
   " unset _cgi(form_in_progress) } Figure 12: The form procedure creates
   an HTML-style form. FAQ generation tion N in qa(N,q) and the
   corresponding answer in qa(N,a). At the same time, the question is
   printed out. Earlier I mentioned that CGI scripts are just a subset of
   Thus, there is no need for the first loop in the earlier HTML
   generation. As an example, consider the task of pseudocode. building an
   FAQ in HTML. There is no benefit to dynamically generating an FAQ  it
   rarely changes. proc question {q a} { However, an FAQ has some of the
   same problems as I global index qa described earlier. For example, it
   can include many incr index links which must be kept current. set
   qa($index,q) $q Another reason that it makes sense to think about
   gener- set qa($index,a) $a ating HTML for an FAQ is that an FAQ is
   highly styl- ized. For example, an FAQ always has a set of puts ""
   questions. These questions are then repeated but with puts "

     $q" answers. Written manually, you would have to literally puts "" }
   repeat the questions and create the links. If a new ques- tion was
   added or an old one deleted, you would have to carefully make sure that
   both entries were handled iden- Each question automatically links to
   its corresponding tically. answer, linked as #qN. When the
   question/answer pairs are later printed, they will have A HREF tags
   defining Intuitively, this could be automated using two loops. the #qN
   targets. First, the questions and answers would be defined. Then the
   first loop would print the questions. The second The source for an
   example question/answer definition is loop would print the questions
   (again) interspersed with shown in Figure 13. the answers. In
   pseudocode: The question is now only stated once and it is always
   define QAs ;# pseudocode! paired with the answer. This simplifies
   maintenance. foreach qa $QAs { Notice that the answer is not simply a
   string. The print_question $qa answer is Tcl code. This makes it
   possible to use all of } the techniques mentioned earlier. For example,
   the example above uses p to generate new paragraphs and foreach qa $QAs
   { print_question $qa link to generate hyperlinks. print_answer $qa }
   The code is evaluated by passing the answer to eval whenever it is
   needed. An answer procedure does this It suffices to store the
   questions and answers in an array. and generates the hyperlink target
   at the same time. The following code numbers each pair and stores ques-
   proc answer {i} { question {I keep hearing about Expect. So what is
   it?} { p "Expect is a tool primarily for automating interactive
   applications such as telnet, ftp, passwd, fsck, rlogin, tip, etc.
   Expect really makes this stuff trivial. Expect is also useful for
   testing these same applications. Expect is described in many books,
   articles, papers, and FAQs. There is an entire [link book] on it
   available from [link ORA]." p "You can ftp Expect from ftp.cme.nist.gov
   as [link Expect.Z] or [link Expect.gz]" p "Expect requires Tcl. If you
   don't already have Tcl, you can get it in the same directory (above) as
   [link Tcl.Z] or [link Tcl.gz]." p "Expect is free and in the public
   domain." };# end question Figure 13: Source to an example
   question/answer definition. global qa cation-specific procedures. For
   instance, suppose a hor- izontal rule is produced using the hr command.
   puts "

   " puts "" Obviously this can be defined as "puts
     __________________________________________________________________

   ". It is eas- puts "

     $qa($i,q)" ily changed to produce text using the following proce-
   puts "" dure: puts "

   " eval $qa($i,a) proc hr {} { } puts ============================ } For
   example, "answer 0" would produce the beginning of the output from the
   earlier question. The full HTML Here are analogous definitions for h1
   and h2. Others are would begin like this: similar.

   proc h1 {s} { puts ""

     I keep hearing about Expect. puts "*" So what is it? puts "* $s" puts
   "*"

   Expect is a tool primarily for puts "" automating interactive . . . }
   The answer procedure itself is called from a loop in proc h2 {s} {
   another procedure called answers (Figure 14). An puts "*** $s ***"
   answer_header procedure prints out a header if one has } been
   associated with the current question. This provides For example, with
   this new definition, "h1 Questions" a way of breaking the FAQ into
   sections. A matching reasonably simulates a level 1 header using only
   text as: procedure (question_header) defines and prints the headers as
   they are encountered. ** Questions proc answer_header {i} { * global qa
   The ability to generate the FAQ in different forms is h3 "$qa($i,h)"
   convenient. For example, it means that people can read } the FAQ
   without having an HTML browser. proc question_header {h} { The
   generation of different formats is simplified by global index qa
   avoiding use of explicit HTML tags and instead using logical procedure
   names. A particular output format can set qa($index,h) $h puts "" be
   produced merely by providing an appropriate set of h3 $h procedure
   definitions. Although I have not done so, it puts "" should be possible
   to adapt the framework and ideas } shown here to produce output in such
   formats as TEX, MIF, and others. Even without translation, avoiding
   Translation to Other Formats explicit HTML is a good idea for the
   reasons mentioned earlier  maintenance and readability. Another benefit
   of using logical tags is that different output formats can be generated
   by changing the appli- proc answers {} { uplevel #0 { start_answers for
   {set index 0} {$index < $maxindex} {incr index} { catch {answer_header
   $index} answer $index hr } } } Figure 14: Generate all the answers in
   the FAQ. A Translation Framework Readers interested in comparative
   strategies to CGI gen- eration should consult the Yahoo database
   [Yahoo] Translation is further simplified by separating the appli-
   which lists CGI libraries for dozens of languages, often
   cation-specific definitions from the content of the partic- with
   multiple entries for each. Readers should also ular document. For
   example, multiple FAQs could reuse explore alternative strategies to
   CGI, such as the Tcl- the same set of FAQ support definitions. Each FAQ
   based server-side programming demonstrated by would start by loading
   the FAQ definitions by means of Audience1 [Sah] and NeoScript [Lehen]
   which ele- a source command appropriate to the desired output: gantly
   solve problems that CGI alone cannot address source FAQdriver.$argv
   adequately. A driver for each output format defines the procedures The
   other aspect of this paper, dynamic document gen- to produce the FAQ in
   that particular format. For exam- eration, is also an area rich in
   development. Various ple, FAQdriver.html would begin: attempts are
   being made to solve this in other ways including SGML and its
   extensions and alternatives. # driver.html - Tcl to HTML procs Good
   discussion of these can be found in [Harman]. proc hr {} {puts "
     __________________________________________________________________

   "} FAQdriver.text would start similarly: Concluding Notes # driver.text
   - Tcl to text procs This paper has shown the benefits of generating
   HTML proc hr {} {puts ===================} from Tcl scripts. CGI
   scripts are an obvious use of this. If short enough, all of the
   different definitions can be However, even static documents benefit by
   increasing maintained as a single file which simply uses a switch to
   readability and improving maintainability. define the appropriate
   definitions. Traditionally, Perl has been the language of choice for
   switch $argv { CGI scripting. However, use of Tcl for CGI scripting
   html { has increased significantly. Part of this is simply due to proc
   emphasis {s} { the number of people who already know Tcl. But Tcl puts
   "$s" brings with it many beneficial attributes: Tcl is a simple }
   language to learn. Its portability is excellent, it is . . . } robust,
   and it has no significant startup overhead. And text { of course it is
   easily embeddable in other applications proc emphasis {s} {puts "*$s*"}
   making it that much easier to leverage ongoing develop- . . . ment in
   languages such as C and C++. } } These are all characteristics that
   make Tcl very attrac- In either case, output generation is then
   accomplished tive for CGI scripting. However, Tcl does not have a by
   executing the document with the argument describ- history of use for
   CGI scripting and there is little docu- ing the desired format. For
   example, assuming the FAQ mentation to help beginners get started.
   Hopefully, this source is stored in ExpectFAQ, HTML is generated paper
   will make it easier for more people to get starting from the command
   line as: writing CGI scripts in Tcl. % ExpectFAQ html Availability Text
   output is generated as: The CGI library described is available at
   http:// % ExpectFAQ text www.cme.nist.gov/pub/expect/cgi.tcl.tar.Z. The
   FAQ library described can be retrieved from the Expect FAQ Experiences
   itself [Libes96]. This software is in the public domain. NIST and I
   would appreciate credit if you use this soft- The techniques described
   in this paper have been used ware. successfully in building several
   projects consisting of large numbers of pages including the NIST
   Application Acknowledgments Protocol Information Base [Lubell] and the
   NIST Iden- tifier Collaboration Service [Libes95]. In addition, they
   Thanks to Josh Lubell, John Buckman, Mark William- have been used to
   construct and maintain several FAQs son, Steve Ray, and the Tcl `96
   program committee for including the Expect FAQ [Libes96]. valuable
   suggestions on this paper. References [BLee] T. Berners-Lee, D.
   Connolly, "Hypertext Markup Language  2.0, RFC 1866, HTML Working
   Group, IETF, Corporation for National Research Initiatives, URL:
   http:// www.w3.org/pub/WWW/MarkUp/html- spec/html-spec_toc.html,
   September 22, 1995. [Harman] Harman, D., "Overview of the Third Text
   REtrieval Conference (TREC-3), NIST Spe- cial Publication 500-225,
   NIST, Gaithers- burg, MD, April 1995. [Lehen] Lehenbauer, K.,
   "NeoScript", URL: http:// www.NeoSoft.com/neoscript/, 1996. [Libes95]
   Libes, D., "NIST Identification Collabora- tion Service", URL:
   http://www- i.cme.nist.gov/cgi-bin/ns/src/welcome.cgi, National
   Institute of Standards and Technol- ogy, 1995. [Libes96] Libes, D.,
   "Expect FAQ", URL: http:// www.cme.nist.gov/pub/expect/FAQ.html",
   National Institute of Standards and Technol- ogy, 1996. [Lubell]
   Lubell, J., "NIST Identification Collabora- tion Service", URL:
   http://www- i.cme.nist.gov/proj/apde/www/apib.htm, National Institute
   of Standards and Technol- ogy, 1996. [Ouster] Ousterhout, J., "Tcl and
   the Tk Toolkit", Addison-Wesley Publishing Co., 1994. [Sah] Sah, A.,
   Brown, K., and Brewer, E., "Pro- gramming the Internet from the
   Server-Side with Tcl and Audience1", Tcl/Tk Workshop 96, Monterey, CA,
   July 10-13, 1996. [Yahoo] "Yahoo!", URL: http://www.yahoo.com/
   Computers_and_Internet/Internet/ World_Wide_Web/
   CGI___Common_Gateway_Interface/, April, 1996.
